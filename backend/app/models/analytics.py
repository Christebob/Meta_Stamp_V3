"""
AI Touch Value™ Analytics Models for META-STAMP V3.

This module provides Pydantic models for storing and calculating AI Touch Value™
compensation results based on the platform's core formula:

    AI Touch Value™ = ModelEarnings × (TrainingContributionScore/100) 
                      × (UsageExposureScore/100) × EquityFactor

Where EquityFactor is fixed at 0.25 (25%) representing the creator's fair share
of value generated when their content is used in AI model training.

The AITouchValueCalculation model supports:
- Precise monetary calculations using Decimal for financial accuracy
- Input validation ensuring scores are within 0-100 range
- Automatic calculation of AI Touch Value™ from inputs
- Historical tracking with timestamps for trend analysis
- Predictive model inputs (followers, views, content hours, platform)
- MongoDB compatibility with proper serialization

Example:
    >>> calc = AITouchValueCalculation(
    ...     user_id="user123",
    ...     model_earnings=Decimal("100000.00"),
    ...     training_contribution_score=75.0,
    ...     usage_exposure_score=60.0
    ... )
    >>> calc.calculated_value  # Decimal("11250.00")
"""

from datetime import datetime, timezone
from decimal import Decimal, InvalidOperation, ROUND_HALF_UP
from typing import Any, Dict, Optional

from pydantic import BaseModel, ConfigDict, Field, field_validator, model_validator


# Constants for the AI Touch Value™ formula
EQUITY_FACTOR: float = 0.25  # Fixed 25% equity factor - NON-NEGOTIABLE per requirements
DEFAULT_CALCULATION_METHOD: str = "standard"
DEFAULT_VERSION: str = "1.0"
SCORE_MIN: float = 0.0
SCORE_MAX: float = 100.0


class AITouchValueCalculation(BaseModel):
    """
    Pydantic model for AI Touch Value™ calculation results.
    
    This model stores the inputs, computed value, and metadata for AI Touch Value™
    calculations used in creator compensation analysis. The calculation follows
    the exact formula specified in the Agent Action Plan:
    
        AI Touch Value™ = ModelEarnings × (TrainingContributionScore/100) 
                          × (UsageExposureScore/100) × 0.25
    
    Attributes:
        id: MongoDB ObjectId string (optional, auto-generated by MongoDB)
        user_id: User identifier for calculation ownership
        asset_id: Optional asset identifier for asset-specific calculations
        model_earnings: AI model earnings to calculate creator's share from (>= 0)
        training_contribution_score: Score 0-100 representing training data contribution
        usage_exposure_score: Score 0-100 representing usage/exposure level
        equity_factor: Fixed at 0.25 (25%) - cannot be modified
        calculated_value: The computed AI Touch Value™ result
        followers_count: Optional social media followers for predictive modeling
        content_hours: Optional total content hours for predictive modeling
        total_views: Optional total views for predictive modeling
        platform: Optional platform name for platform-specific calculations
        calculation_method: Versioning identifier for calculation method
        version: Formula version for tracking calculation algorithm changes
        metadata: Flexible dictionary for additional calculation context
        created_at: UTC timestamp of calculation creation
        expires_at: Optional expiration timestamp for time-sensitive projections
    
    Example:
        >>> from decimal import Decimal
        >>> calc = AITouchValueCalculation(
        ...     user_id="user_abc123",
        ...     model_earnings=Decimal("50000.00"),
        ...     training_contribution_score=80.0,
        ...     usage_exposure_score=70.0
        ... )
        >>> print(calc.calculated_value)
        7000.00
        >>> print(calc.equity_factor)
        0.25
    """
    
    # MongoDB configuration for proper serialization and aliasing
    model_config = ConfigDict(
        populate_by_name=True,
        json_encoders={
            Decimal: lambda v: str(v),
            datetime: lambda v: v.isoformat(),
        },
        arbitrary_types_allowed=True,
        str_strip_whitespace=True,
    )
    
    # =========================================================================
    # Core Identification Fields
    # =========================================================================
    
    id: Optional[str] = Field(
        default=None,
        alias="_id",
        description="MongoDB ObjectId as string for database identification"
    )
    
    user_id: str = Field(
        ...,
        min_length=1,
        description="User identifier for calculation ownership and association"
    )
    
    asset_id: Optional[str] = Field(
        default=None,
        description="Optional asset identifier for asset-specific calculations"
    )
    
    # =========================================================================
    # Core Calculation Input Fields
    # =========================================================================
    
    model_earnings: Decimal = Field(
        ...,
        ge=Decimal("0"),
        description="AI model earnings in currency units (must be >= 0)"
    )
    
    training_contribution_score: float = Field(
        ...,
        ge=SCORE_MIN,
        le=SCORE_MAX,
        description="Training data contribution score from 0-100"
    )
    
    usage_exposure_score: float = Field(
        ...,
        ge=SCORE_MIN,
        le=SCORE_MAX,
        description="Usage/exposure score from 0-100"
    )
    
    equity_factor: float = Field(
        default=EQUITY_FACTOR,
        description="Fixed equity factor at 0.25 (25%) - cannot be modified"
    )
    
    calculated_value: Optional[Decimal] = Field(
        default=None,
        description="Computed AI Touch Value™ result"
    )
    
    # =========================================================================
    # Prediction Input Fields (for predictive modeling)
    # =========================================================================
    
    followers_count: Optional[int] = Field(
        default=None,
        ge=0,
        description="Social media followers count for predictive modeling"
    )
    
    content_hours: Optional[float] = Field(
        default=None,
        ge=0.0,
        description="Total content hours for content volume metrics"
    )
    
    total_views: Optional[int] = Field(
        default=None,
        ge=0,
        description="Total views count for exposure metrics"
    )
    
    platform: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Platform name for platform-specific calculations"
    )
    
    # =========================================================================
    # Calculation Metadata Fields
    # =========================================================================
    
    calculation_method: str = Field(
        default=DEFAULT_CALCULATION_METHOD,
        description="Calculation method identifier for versioning"
    )
    
    version: str = Field(
        default=DEFAULT_VERSION,
        description="Formula version for tracking algorithm changes"
    )
    
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional context, assumptions, and platform-specific parameters"
    )
    
    # =========================================================================
    # Timestamp Fields
    # =========================================================================
    
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        description="UTC timestamp of calculation creation"
    )
    
    expires_at: Optional[datetime] = Field(
        default=None,
        description="Optional expiration timestamp for time-sensitive projections"
    )
    
    # =========================================================================
    # Field Validators
    # =========================================================================
    
    @field_validator("model_earnings", mode="before")
    @classmethod
    def validate_model_earnings(cls, value: Any) -> Decimal:
        """
        Validate and convert model_earnings to Decimal.
        
        Ensures the value is a valid non-negative number that can be
        converted to Decimal for precise financial calculations.
        
        Args:
            value: Input value (can be str, int, float, or Decimal)
            
        Returns:
            Decimal: Validated model earnings value
            
        Raises:
            ValueError: If value is negative or cannot be converted to Decimal
        """
        if value is None:
            raise ValueError("model_earnings is required and cannot be None")
        
        try:
            # Convert to Decimal if not already
            if isinstance(value, Decimal):
                decimal_value = value
            elif isinstance(value, (int, float)):
                decimal_value = Decimal(str(value))
            elif isinstance(value, str):
                decimal_value = Decimal(value)
            else:
                raise ValueError(
                    f"model_earnings must be a number, got {type(value).__name__}"
                )
            
            # Ensure non-negative
            if decimal_value < Decimal("0"):
                raise ValueError(
                    f"model_earnings must be >= 0, got {decimal_value}"
                )
            
            # Round to 2 decimal places for currency precision
            return decimal_value.quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)
            
        except InvalidOperation as e:
            raise ValueError(
                f"model_earnings must be a valid decimal number: {e}"
            ) from e
    
    @field_validator("training_contribution_score", mode="before")
    @classmethod
    def validate_training_score(cls, value: Any) -> float:
        """
        Validate training_contribution_score is within 0-100 range.
        
        Args:
            value: Input score value
            
        Returns:
            float: Validated score
            
        Raises:
            ValueError: If score is outside 0-100 range
        """
        if value is None:
            raise ValueError("training_contribution_score is required")
        
        try:
            score = float(value)
        except (TypeError, ValueError) as e:
            raise ValueError(
                f"training_contribution_score must be a number, got {type(value).__name__}"
            ) from e
        
        if score < SCORE_MIN or score > SCORE_MAX:
            raise ValueError(
                f"training_contribution_score must be between {SCORE_MIN} and "
                f"{SCORE_MAX}, got {score}"
            )
        
        return score
    
    @field_validator("usage_exposure_score", mode="before")
    @classmethod
    def validate_exposure_score(cls, value: Any) -> float:
        """
        Validate usage_exposure_score is within 0-100 range.
        
        Args:
            value: Input score value
            
        Returns:
            float: Validated score
            
        Raises:
            ValueError: If score is outside 0-100 range
        """
        if value is None:
            raise ValueError("usage_exposure_score is required")
        
        try:
            score = float(value)
        except (TypeError, ValueError) as e:
            raise ValueError(
                f"usage_exposure_score must be a number, got {type(value).__name__}"
            ) from e
        
        if score < SCORE_MIN or score > SCORE_MAX:
            raise ValueError(
                f"usage_exposure_score must be between {SCORE_MIN} and "
                f"{SCORE_MAX}, got {score}"
            )
        
        return score
    
    @field_validator("equity_factor", mode="before")
    @classmethod
    def validate_equity_factor(cls, value: Any) -> float:
        """
        Validate equity_factor is always 0.25 (25%).
        
        The equity factor is a fixed constant per the AI Touch Value™ formula
        and cannot be modified. Any attempt to set a different value will
        be overridden to 0.25.
        
        Args:
            value: Input equity factor value (ignored, always returns 0.25)
            
        Returns:
            float: Always returns EQUITY_FACTOR (0.25)
        """
        # Equity factor is FIXED at 0.25 - cannot be modified per requirements
        # Log a warning if someone tried to set a different value
        if value is not None and value != EQUITY_FACTOR:
            # Silently enforce the fixed value - this is intentional per spec
            pass
        return EQUITY_FACTOR
    
    @field_validator("calculated_value", mode="before")
    @classmethod
    def validate_calculated_value(cls, value: Any) -> Optional[Decimal]:
        """
        Validate and convert calculated_value to Decimal if provided.
        
        This field is typically auto-calculated by the model_validator,
        but can be provided directly when loading from database.
        
        Args:
            value: Input calculated value
            
        Returns:
            Optional[Decimal]: Validated calculated value or None
        """
        if value is None:
            return None
        
        try:
            if isinstance(value, Decimal):
                return value.quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)
            elif isinstance(value, (int, float)):
                return Decimal(str(value)).quantize(
                    Decimal("0.01"), rounding=ROUND_HALF_UP
                )
            elif isinstance(value, str):
                return Decimal(value).quantize(
                    Decimal("0.01"), rounding=ROUND_HALF_UP
                )
            else:
                raise ValueError(
                    f"calculated_value must be a number, got {type(value).__name__}"
                )
        except InvalidOperation as e:
            raise ValueError(
                f"calculated_value must be a valid decimal number: {e}"
            ) from e
    
    # =========================================================================
    # Model Validator for Automatic Calculation
    # =========================================================================
    
    @model_validator(mode="after")
    def compute_ai_touch_value(self) -> "AITouchValueCalculation":
        """
        Automatically calculate the AI Touch Value™ after all fields are validated.
        
        This model validator runs after all field validations are complete and
        computes the calculated_value using the exact formula:
        
            AI Touch Value™ = ModelEarnings × (TrainingContributionScore/100) 
                              × (UsageExposureScore/100) × 0.25
        
        The calculation is performed using Decimal arithmetic for financial
        precision, avoiding floating-point errors.
        
        Returns:
            AITouchValueCalculation: The instance with calculated_value populated
        """
        # Only calculate if not already set (allows loading from database)
        if self.calculated_value is None:
            self.calculated_value = self.calculate()
        
        return self
    
    # =========================================================================
    # Calculation Methods
    # =========================================================================
    
    def calculate(self) -> Decimal:
        """
        Calculate the AI Touch Value™ using the exact formula.
        
        Implements the AI Touch Value™ formula as specified:
        
            AI Touch Value™ = ModelEarnings × (TrainingContributionScore/100) 
                              × (UsageExposureScore/100) × 0.25
        
        The calculation uses Decimal arithmetic throughout to ensure precise
        financial calculations without floating-point errors.
        
        Returns:
            Decimal: The calculated AI Touch Value™ rounded to 2 decimal places
            
        Example:
            >>> calc = AITouchValueCalculation(
            ...     user_id="user123",
            ...     model_earnings=Decimal("100000.00"),
            ...     training_contribution_score=75.0,
            ...     usage_exposure_score=60.0
            ... )
            >>> calc.calculate()
            Decimal('11250.00')
            
        Notes:
            - With model_earnings=$100,000, contribution=75%, exposure=60%, equity=25%:
              $100,000 × 0.75 × 0.60 × 0.25 = $11,250.00
        """
        # Convert scores to Decimal for precision
        contribution_factor = Decimal(str(self.training_contribution_score)) / Decimal("100")
        exposure_factor = Decimal(str(self.usage_exposure_score)) / Decimal("100")
        equity = Decimal(str(self.equity_factor))
        
        # Apply the exact formula: ModelEarnings × (Score1/100) × (Score2/100) × 0.25
        result = self.model_earnings * contribution_factor * exposure_factor * equity
        
        # Round to 2 decimal places for currency precision
        return result.quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)
    
    def recalculate(self) -> Decimal:
        """
        Force recalculation of the AI Touch Value™ and update the stored value.
        
        This method recalculates the AI Touch Value™ and updates the
        calculated_value field. Useful when input values have been modified.
        
        Returns:
            Decimal: The newly calculated AI Touch Value™
        """
        self.calculated_value = self.calculate()
        return self.calculated_value
    
    def get_calculation_breakdown(self) -> Dict[str, Any]:
        """
        Get a detailed breakdown of the AI Touch Value™ calculation.
        
        Returns a dictionary containing the formula, all input values,
        intermediate calculations, and the final result for transparency
        and audit purposes.
        
        Returns:
            Dict[str, Any]: Calculation breakdown with all components
            
        Example:
            >>> calc = AITouchValueCalculation(
            ...     user_id="user123",
            ...     model_earnings=Decimal("100000.00"),
            ...     training_contribution_score=75.0,
            ...     usage_exposure_score=60.0
            ... )
            >>> breakdown = calc.get_calculation_breakdown()
            >>> breakdown['formula']
            'AI Touch Value™ = ModelEarnings × (TrainingContributionScore/100) × (UsageExposureScore/100) × EquityFactor'
        """
        contribution_factor = self.training_contribution_score / 100
        exposure_factor = self.usage_exposure_score / 100
        
        return {
            "formula": (
                "AI Touch Value™ = ModelEarnings × (TrainingContributionScore/100) "
                "× (UsageExposureScore/100) × EquityFactor"
            ),
            "inputs": {
                "model_earnings": str(self.model_earnings),
                "training_contribution_score": self.training_contribution_score,
                "usage_exposure_score": self.usage_exposure_score,
                "equity_factor": self.equity_factor,
            },
            "factors": {
                "contribution_factor": contribution_factor,
                "exposure_factor": exposure_factor,
                "combined_multiplier": contribution_factor * exposure_factor * self.equity_factor,
            },
            "result": {
                "calculated_value": str(self.calculated_value),
                "currency": "USD",
            },
            "metadata": {
                "calculation_method": self.calculation_method,
                "version": self.version,
                "calculated_at": self.created_at.isoformat(),
            },
        }
    
    def is_expired(self) -> bool:
        """
        Check if this calculation has expired.
        
        Returns:
            bool: True if expires_at is set and has passed, False otherwise
        """
        if self.expires_at is None:
            return False
        return datetime.now(timezone.utc) > self.expires_at
    
    def to_mongodb_dict(self) -> Dict[str, Any]:
        """
        Convert the model to a dictionary suitable for MongoDB storage.
        
        Handles proper serialization of Decimal and datetime fields for
        MongoDB compatibility.
        
        Returns:
            Dict[str, Any]: Dictionary ready for MongoDB insertion
        """
        data = self.model_dump(by_alias=True, exclude_none=False)
        
        # Convert Decimal fields to string for MongoDB storage
        if data.get("model_earnings") is not None:
            data["model_earnings"] = str(data["model_earnings"])
        if data.get("calculated_value") is not None:
            data["calculated_value"] = str(data["calculated_value"])
        
        # Remove _id if None (let MongoDB generate it)
        if data.get("_id") is None:
            data.pop("_id", None)
        
        return data
    
    @classmethod
    def from_mongodb_dict(cls, data: Dict[str, Any]) -> "AITouchValueCalculation":
        """
        Create an AITouchValueCalculation instance from a MongoDB document.
        
        Handles proper deserialization of string Decimal fields back to
        Decimal objects.
        
        Args:
            data: MongoDB document dictionary
            
        Returns:
            AITouchValueCalculation: Reconstructed model instance
        """
        # Convert _id to string if it's an ObjectId
        if "_id" in data and data["_id"] is not None:
            data["_id"] = str(data["_id"])
        
        # Convert string Decimal fields back to Decimal
        if "model_earnings" in data and isinstance(data["model_earnings"], str):
            data["model_earnings"] = Decimal(data["model_earnings"])
        if "calculated_value" in data and isinstance(data["calculated_value"], str):
            data["calculated_value"] = Decimal(data["calculated_value"])
        
        return cls(**data)


# Export the model class
__all__ = ["AITouchValueCalculation"]
